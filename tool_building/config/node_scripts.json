{
    "router": {
        "script": "from swarm.swarm import Swarm\nasync def router(goal):\n    swarm = Swarm()\n    router_agent = swarm.agents['router']\n    options = ['user_assistance', 'python_coder', 'manager', 'writer', 'retrieval']\n    \n    agent_index = await router_agent.chat(goal)\n    agent_index = agent_index['arguments']['agent_index']\n    \n    if agent_index == 0: # User assistance\n        while True:\n            user_input = input(f\"The router agent needs assistance routing this goal:\\n\\n{goal}\\n\\nPlease choose the index of the agent this goal should be routed to: {options}\")\n            if user_input.isdigit():\n                user_number = int(user_input)\n                if 1 <= user_number <= len(options):\n                    print(f\"You chose the number: {user_number}\")\n                    agent_index = user_number\n                    break\n                else:\n                    print(\"Number out of range. Please try again. Don't select user_assistance again.\")\n            else:\n                print(\"Invalid input. Please enter a number.\")\n                \n    node_blueprints = [{'type': options[agent_index], 'data': {'goal': goal}}]\n    return {'action': 'spawn', 'node_blueprints': node_blueprints}\n",
        "description": "Routes a task to the appropriate next action.\n\tInput: A list of subtasks (list), a string describing the context of the goal (str), and a boolean indicating whether the subtasks should be executed in parallel or sequentially (bool)\n\tReturns: None\nCalls the subtask_router_agent to route a subtask to the appropriate next action. Schedules tasks in swarm correspondingly:\nA dictionary with the following keys:\n\t'next_action': An integer indicating the next action to take (1: break_down_goal, 2: write_text, 3: write_python, 4: retrieve_info, 5: ask_user_for_help)",
        "language": "python"
    },
    "manager": {
        "script": "from swarm.swarm import Swarm\nasync def manager(goal):\n    swarm = Swarm()\n    manager = swarm.agents['manager']\n    \n    while True:\n        broken_down_goal = await manager.chat(goal)\n        agent_has_questions = broken_down_goal['arguments']['do_you_have_questions']\n\n        if agent_has_questions:\n            question = broken_down_goal['arguments']['question']\n            user_input = input(f\"\\n\\nQuestions: {question}\\n\\nGoal: {goal}\\n\\n\")\n            goal = f'{goal}\\n\\nQuestion: {question} \\n\\nUser answer: {user_input}'\n        else:\n            subgoals = broken_down_goal['arguments']['subgoals']\n            break\n            \n    node_blueprints = []\n    for subgoal in subgoals:\n        node_blueprints.append({'type': 'router', 'data': {'goal': subgoal}})\n\n    return {'action': 'spawn', 'node_blueprints': node_blueprints}\n",
        "description": "Breaks down a goal into subtasks.\n\tInput: Any arbitray goal (str)\n\tReturns: None\nCalls the head_agent to break down the goal. Then, calls the router_agent to route subtasks to the appropriate next action. Passes this to router from head_agent:\nA dictionary with the following keys:\n\t'subtasks': A list of subtasks (str)\n\t'context': A string describing the context of the goal\n\t'is_parallel': A boolean indicating whether the subtasks should be executed in parallel or sequentially",
        "language": "python"
    },
    "python_coder": {
        "script": "from swarm.swarm import Swarm\nfrom settings import Settings\nimport json\nsettings = Settings() # For config paths\n\nasync def python_coder(goal):\n    swarm = Swarm()\n    \n    # Gather all relevant context\n    code_analyst = swarm.agents['code_analyst']\n    while True:\n        questions = await code_analyst.chat(goal)\n        analyst_has_questions = questions['arguments']['do_you_have_questions']\n        \n        if analyst_has_questions:\n            questions = questions['arguments']['questions']\n            user_input = input(f\"\\n\\nGoal: {goal}\\n\\nQuestions: {questions}\\n\")\n            goal = f'{goal}\\n\\nQuestions: {questions} \\n\\nUser answer: {user_input}'\n        else: \n            break\n\n    # Write code\n    python_coder = swarm.agents['python_coder']\n    code = await python_coder.chat(goal)\n    code = code['arguments']['python_code']\n    python_metadata_extractor = swarm.agents['python_metadata_extractor']\n    metadata = await python_metadata_extractor.chat(code)\n    name = metadata['arguments']['name']\n    code_type = ['function', 'class', 'script', 'other']\n    packet = {\n        'language': 'python',\n        'code_type': code_type[metadata['arguments']['code_type']],\n        'code': code,\n        'description': metadata['arguments']['description'],\n        'dependencies': metadata['arguments'].get('dependencies', [])\n    }\n\n    file_name = settings.SYNTHETIC_CODE_PATH\n    with open(file_name, 'r') as file:\n        data = json.load(file)\n    data[name] = packet\n    with open(file_name, 'w') as file:\n        json.dump(data, file, indent=4)\n\n    node_blueprints = [{'type': 'python_script_tester', 'data': {'code_key': name}}]\n    return {'action': 'spawn', 'node_blueprints': node_blueprints}    \n",
        "description": "",
        "language": ""
    },
    "python_script_tester": {
        "script": "from settings import Settings\nimport json\nfrom swarm.swarm import Swarm\nimport os\n\nsettings = Settings()\nwith open(settings.AUTONOMOUS_SCRIPT_TESTS_PATH, 'r') as file:\n    autonomous_test_data = json.load(file)\n    \n# DO same but with manualk\nwith open(settings.MANUAL_SCRIPT_TESTS_PATH, 'r') as file:\n    manual_test_data = json.load(file)\n    \ndef save_test_progress(data, code_key, inner_key, value):\n    if code_key not in data:\n        data[code_key] = {} \n    if inner_key not in data[code_key]:\n        data[code_key][inner_key] = {} \n    data[code_key][inner_key] = value\n    with open(settings.AUTONOMOUS_SCRIPT_TESTS_PATH, 'w') as file:\n        json.dump(data, file, indent=4)\n        \nasync def python_script_tester(code_key):\n    swarm = Swarm()\n    with open(settings.SYNTHETIC_CODE_PATH, 'r') as file:\n        data = json.load(file)\n    synthetic_code_bundle = data[code_key]\n    code = synthetic_code_bundle['code']\n    description = synthetic_code_bundle['description']\n    save_test_progress(autonomous_test_data, code_key, 'original_script', code)\n    \n    try:\n        # Assess the script\n        python_script_assessor_pre_testing = swarm.agents['python_script_assessor_pre_testing']\n        script_assessment = await python_script_assessor_pre_testing.chat(f'<CODE STARTS>\\n{code}\\n<CODE ENDS>\\n{description}')\n        save_test_progress(autonomous_test_data, code_key, 'script_assessment', script_assessment['arguments'])\n        \n        # Generate a script to test the script\n        message_to_generate_proper_script = f'<CODE STARTS>\\n{code}\\n<CODE ENDS>\\n<DESCRIPTION>\\n{description}\\n<DESCRIPTION ENDS>\\n'\n        if script_assessment['arguments']['is_script_runnable_as_is']:\n            message_to_generate_proper_script += '\\n<Script is runnable as is.>\\n'\n        else:\n            message_to_generate_proper_script += '\\n<Script is not runnable as is. You need to leave the script unchanged, adding logic to execute and fill in blank parameters as necessary.>\\n'\n            if script_assessment['arguments'].get('needs_user_provided_parameters', False):\n                user_input = input(f\"\\n\\nThe python script tester needs you to provide input parameters to test this script: \\n{code}\\n\\nPlease provide the name of the parameters followed by the value.\")\n                message_to_generate_proper_script += f'<USER PARAMS>\\n{user_input}\\n<USER PARAMS ENDS>\\n'\n        message_to_generate_proper_script += f\"\\n**Success Logging Params**:\\nJSON_SAVE_SUCCESS_PATH = '{settings.AUTONOMOUS_SCRIPT_TESTS_PATH}'\\nSCRIPT_KEY = '{code_key}'\"\n        executable_python_test_script_generator = swarm.agents['executable_python_test_script_generator']\n        executable_script = await executable_python_test_script_generator.chat(message_to_generate_proper_script)\n        save_test_progress(autonomous_test_data, code_key, 'synthetic_executable_script_for_testing', executable_script['arguments']['executable_script'])\n        \n        # Execute the script that tests the script\n        try: \n            exec(executable_script['arguments']['executable_script'])  \n        except Exception as e:\n            error_message = f\"Error executing script {code_key}: {e}\"\n            save_test_progress(autonomous_test_data, code_key, 'error', error_message)\n            raise Exception(error_message)\n    except: # If the autonomous testing fails at any point, we need to manually prepare the script for testing\n        manual_test_file_path = f'{settings.MANUAL_TESTING_GROUND_FOLDER_PATH}/{code_key}.py'\n        save_test_progress(manual_test_data, code_key, 'original_script', code)\n        if not os.path.exists(manual_test_file_path):\n            open(manual_test_file_path, 'w').close()\n        with open(manual_test_file_path, 'w') as file:\n            file.write(code)\n        user_input = input(f'\\nThe autonomous script tester failed. Please manually prepare the script for testing at {manual_test_file_path} and press enter when ready.\\nAdd logic to save the result of the successful test in {settings.MANUAL_SCRIPT_TESTS_PATH} file as follows:\\nPrepare a success message that includes two dictionaries:\\n- input: Containing the parameters used for the test.\\n- output: Detailing the results or outputs from the test execution.\\nThese will be added to a JSON file so make sure they are serializable. Leave out non-serializable data.\\nSave the success dict to the file: {settings.MANUAL_SCRIPT_TESTS_PATH} with the key: {code_key}\\n\\nPress enter when ready.\\n')\n        \n        try:\n            with open(manual_test_file_path, 'r') as file:\n                manually_prepared_test_script = file.read()\n                save_test_progress(manual_test_data, code_key, 'manually_prepared_test_script', manually_prepared_test_script)\n                exec(manually_prepared_test_script)\n        except Exception as e:\n            error_message = f\"Error executing script {code_key}: {e}\"\n            save_test_progress(manual_test_data, code_key, 'error', error_message)\n            raise Exception(error_message)\n        \n    return {'action': 'terminate', 'node_blueprints': []}\n    # Ok. so now we should have a success message in the autonomous or manual test data, or an error message in the autonomous test data. what do we do now?\n\n    \n    \n",
        "description": "",
        "language": ""
    }
}